* kwargs to gameitem constructor should convert tuples to quaternions
* camera in wobblyorbit
* anti-alias polygon edges? Does this even make sense for closed polyhedra?
* demo.py should create a more funky shape
* Put demo.py in 'examples' dir
* Convert options to use argparse, so that it can provide command line usage

* Add all good shapes from previous programs

* eventloop in top level package?
* color in top level package?
* render? world? what else?
* camera should not be attribute of eventloop. Do we need a 'view' class
  that instantiates window & camera?

* Dependencies should be in a virtualenv. Put virtualenv creation script,
  or 'frozen' version number output, into hg
* Euclid should be a virtualenv installed dependency, not bundled.
  (& then remove path.append in demo.py)
* should be pip installable, and doing so should install its deps
* Check that demo.py works in isolation, using an installed version of gloopy
* Consider getting pyglet latest svn

* generate sphinx documentation
* fill in doc strings
* make 0.1 release on cheese shop


AFTER 0.1 RELEASE ------------------------------------------------------------

* Review TODO docs from 'pyweek11' and 'hobbyist opengl' talk, transfer
  good parts into this document
* Review whether gloopy is about opengl rendering, gameitem movement and
  orientation (and composition, etc), or both. Should be separate libraries?

* measure performance - doesn't look like we're getting 60fps
* scale movement by mean dt over last few frames to avoid jittery movement
  caused by isolated aberrant frames.
* add option to use pyglet or pyopengl bindings. measure performance.
* read up on how to make pyopengl faster

* Combining the orientations of nested multishapes is done in an innefficient
  manner, multiplying every vertex by each multishape's orientation in
  series. Modify to calculate the cumulative orientation first, then
  multiply each vertex by the result.
* Optionally use VBOs if they are available. Otherwise silently fall back
  to vertex arrays
* Introduce a variable to control the use of primitives other than
  GL_TRIANGLES. When using GL_TRIANGLE_FAN or _STRIP, draw all the
  discontinuous faces of a single shape in a single draw call, using:
    glEnable( GL_PRIMITIVE_RESTART )
    glPrimitiveRestartIndex( MAXINT ) # for eg
  and then insert indices of value MAXINT into the index array to form a
  break between strips. Bear in mind this is meant to be a space & time
  optimisation, so measure the latter before deciding the keep it.
* log gloopy version number should include hg revision?
* log file should be created in app_root if possible, or else in
  application's scratch space, not cwd

* bool to display or hide clockdisplay
* Control over ambient and directional light sources
* Point light sources
* Textures

* Start work on the pycon talk demo that will be produced using gloopy
  How about the polyhedran face-extruder?
* Use gloopy to implement the original vision for pyweek11CubeCaught

* orbit should not move the object discontinuously, but should smoothly
  interpolate from initial position to orbit
  (interpolate not quite right - might result in reversal of direction
  towards the end. How to generate a feasible-looking orbital insertion?)
* how to generalise the above for all movers?
* how to use a mover both as an update function, and call one from an update
  function?


PERFORMANCE ------------------------------------------------------------------

* Pass an array of gameitem positions directly to the shaders. Add an integer
  vertex attribute to say which gameitem the vertex belongs to (i.e. an index
  into the gameitem positions array.) There is then no need to update
  modelview between draw calls. Do the same with orientation, and then all
  objects could be drawn with a single glDraw call.
* Use numpy to maintain the array of positions. It could add an array of
  velocities to it every frame. Also possibly add an array of accellerations
  to the array of velocities. Python code would just need to update occasional
  impulses into the accel or velocity arrays.
* Cython the inner render loop


IDEAS FOR LATER --------------------------------------------------------------

* Curved surfaces (i.e. re-use same vertex (incl. normals) between adjacent
  triangles)
* Generate equipotential surfaces in scalar fields
* Use that to generate cool organic shapes with holes,
  eg. see screenshots on the geexlab website
* Noise shaders
* Geometry instancing, see techniques enumerated here:
  http://www.geeks3d.com/20100629/test-opengl-geometry-instancing-geforce-gtx-480-vs-radeon-hd-5870/
* Try enabling gamma correction using: glEnable(GL_FRAMEBUFFER_SRGB)
  This can make a huge difference to the results of lighting
* 2D mode, with ortho projection and 2D verts

DONE -------------------------------------------------------------------------

* delete bits of pyweek11 game that aren't required by gloopy,
* move required bits of pyweek11 specific functionality out to demo.py
* presumably glooby, as a library, should not have a main.py
* move stuff out of demo.py into new gloopy.init()
* creation of cube and a non-default sky color should be done by demo.py
* Named colors: use the xkcd database, as staticmethods on Color
* Eventloop knows about many unrelated things
* Log the version number of gloopy
* Log opengl info
* Log options
* Gameitem orientations
* Gameitem spinners
* Gameitem movement

